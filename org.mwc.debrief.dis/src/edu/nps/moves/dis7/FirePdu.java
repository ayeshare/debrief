package edu.nps.moves.dis7;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.Serializable;

/**
 * The firing of a weapon or expendable shall be communicated by issuing a Fire
 * PDU. Sectioin 7.3.2. COMPLETE
 *
 * Copyright (c) 2008-2016, MOVES Institute, Naval Postgraduate School. All
 * rights reserved. This work is licensed under the BSD open source license,
 * available at https://www.movesinstitute.org/licenses/bsd.html
 *
 * @author DMcG
 */
public class FirePdu extends WarfareFamilyPdu implements Serializable {
	/**
	 *
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * This field shall specify the entity identification of the fired munition or
	 * expendable. This field shall be represented by an Entity Identifier record
	 * (see 6.2.28).
	 */
	protected EntityID munitionExpendibleID = new EntityID();

	/**
	 * This field shall contain an identification generated by the firing entity to
	 * associate related firing and detonation events. This field shall be
	 * represented by an Event Identifier record (see 6.2.34).
	 */
	protected EventIdentifier eventID = new EventIdentifier();

	/**
	 * This field shall identify the fire mission (see 5.4.3.3). This field shall be
	 * representedby a 32-bit unsigned integer.
	 */
	protected long fireMissionIndex;

	/**
	 * This field shall specify the location, in world coordinates, from which the
	 * munition was launched, and shall be represented by a World Coordinates record
	 * (see 6.2.97).
	 */
	protected Vector3Double locationInWorldCoordinates = new Vector3Double();

	/**
	 * This field shall describe the firing or launch of a munition or expendable
	 * represented by one of the following types of Descriptor records: Munition
	 * Descriptor (6.2.20.2) or Expendable Descriptor (6.2.20.4).
	 */
	protected MunitionDescriptor descriptor = new MunitionDescriptor();

	/**
	 * This field shall specify the velocity of the fired munition at the point when
	 * the issuing simulation application intends the externally visible effects of
	 * the launch (e.g. exhaust plume or muzzle blast) to first become apparent. The
	 * velocity shall be represented in world coordinates. This field shall be
	 * represented by a Linear Velocity Vector record [see 6.2.95 item c)].
	 */
	protected Vector3Float velocity = new Vector3Float();

	/**
	 * This field shall specify the range that an entityâ€™s fire control system has
	 * assumed in computing the fire control solution. This field shall be
	 * represented by a 32-bit floating point number in meters. For systems where
	 * range is unknown or unavailable, this field shall contain a value of zero.
	 */
	protected float range;

	/** Constructor */
	public FirePdu() {
		setPduType((short) 2);
	}

	/*
	 * The equals method doesn't always work--mostly it works only on classes that
	 * consist only of primitives. Be careful.
	 */
	@Override
	public boolean equals(final Object obj) {

		if (this == obj) {
			return true;
		}

		if (obj == null) {
			return false;
		}

		if (getClass() != obj.getClass())
			return false;

		return equalsImpl(obj);
	}

	@Override
	public boolean equalsImpl(final Object obj) {
		boolean ivarsEqual = true;

		if (!(obj instanceof FirePdu))
			return false;

		final FirePdu rhs = (FirePdu) obj;

		if (!(munitionExpendibleID.equals(rhs.munitionExpendibleID)))
			ivarsEqual = false;
		if (!(eventID.equals(rhs.eventID)))
			ivarsEqual = false;
		if (!(fireMissionIndex == rhs.fireMissionIndex))
			ivarsEqual = false;
		if (!(locationInWorldCoordinates.equals(rhs.locationInWorldCoordinates)))
			ivarsEqual = false;
		if (!(descriptor.equals(rhs.descriptor)))
			ivarsEqual = false;
		if (!(velocity.equals(rhs.velocity)))
			ivarsEqual = false;
		if (!(range == rhs.range))
			ivarsEqual = false;

		return ivarsEqual && super.equalsImpl(rhs);
	}

	public MunitionDescriptor getDescriptor() {
		return descriptor;
	}

	public EventIdentifier getEventID() {
		return eventID;
	}

	public long getFireMissionIndex() {
		return fireMissionIndex;
	}

	public Vector3Double getLocationInWorldCoordinates() {
		return locationInWorldCoordinates;
	}

	@Override
	public int getMarshalledSize() {
		int marshalSize = 0;

		marshalSize = super.getMarshalledSize();
		marshalSize = marshalSize + munitionExpendibleID.getMarshalledSize(); // munitionExpendibleID
		marshalSize = marshalSize + eventID.getMarshalledSize(); // eventID
		marshalSize = marshalSize + 4; // fireMissionIndex
		marshalSize = marshalSize + locationInWorldCoordinates.getMarshalledSize(); // locationInWorldCoordinates
		marshalSize = marshalSize + descriptor.getMarshalledSize(); // descriptor
		marshalSize = marshalSize + velocity.getMarshalledSize(); // velocity
		marshalSize = marshalSize + 4; // range

		return marshalSize;
	}

	public EntityID getMunitionExpendibleID() {
		return munitionExpendibleID;
	}

	public float getRange() {
		return range;
	}

	public Vector3Float getVelocity() {
		return velocity;
	}

	@Override
	public void marshal(final DataOutputStream dos) {
		super.marshal(dos);
		try {
			munitionExpendibleID.marshal(dos);
			eventID.marshal(dos);
			dos.writeInt((int) fireMissionIndex);
			locationInWorldCoordinates.marshal(dos);
			descriptor.marshal(dos);
			velocity.marshal(dos);
			dos.writeFloat(range);
		} // end try
		catch (final Exception e) {
			System.out.println(e);
		}
	} // end of marshal method

	/**
	 * Packs a Pdu into the ByteBuffer.
	 *
	 * @throws java.nio.BufferOverflowException if buff is too small
	 * @throws java.nio.ReadOnlyBufferException if buff is read only
	 * @see java.nio.ByteBuffer
	 * @param buff The ByteBuffer at the position to begin writing
	 * @since ??
	 */
	@Override
	public void marshal(final java.nio.ByteBuffer buff) {
		super.marshal(buff);
		munitionExpendibleID.marshal(buff);
		eventID.marshal(buff);
		buff.putInt((int) fireMissionIndex);
		locationInWorldCoordinates.marshal(buff);
		descriptor.marshal(buff);
		velocity.marshal(buff);
		buff.putFloat(range);
	} // end of marshal method

	public void setDescriptor(final MunitionDescriptor pDescriptor) {
		descriptor = pDescriptor;
	}

	public void setEventID(final EventIdentifier pEventID) {
		eventID = pEventID;
	}

	public void setFireMissionIndex(final long pFireMissionIndex) {
		fireMissionIndex = pFireMissionIndex;
	}

	public void setLocationInWorldCoordinates(final Vector3Double pLocationInWorldCoordinates) {
		locationInWorldCoordinates = pLocationInWorldCoordinates;
	}

	public void setMunitionExpendibleID(final EntityID pMunitionExpendibleID) {
		munitionExpendibleID = pMunitionExpendibleID;
	}

	public void setRange(final float pRange) {
		range = pRange;
	}

	public void setVelocity(final Vector3Float pVelocity) {
		velocity = pVelocity;
	}

	@Override
	public void unmarshal(final DataInputStream dis) {
		super.unmarshal(dis);

		try {
			munitionExpendibleID.unmarshal(dis);
			eventID.unmarshal(dis);
			fireMissionIndex = dis.readInt();
			locationInWorldCoordinates.unmarshal(dis);
			descriptor.unmarshal(dis);
			velocity.unmarshal(dis);
			range = dis.readFloat();
		} // end try
		catch (final Exception e) {
			System.out.println(e);
		}
	} // end of unmarshal method

	/**
	 * Unpacks a Pdu from the underlying data.
	 *
	 * @throws java.nio.BufferUnderflowException if buff is too small
	 * @see java.nio.ByteBuffer
	 * @param buff The ByteBuffer at the position to begin reading
	 * @since ??
	 */
	@Override
	public void unmarshal(final java.nio.ByteBuffer buff) {
		super.unmarshal(buff);

		munitionExpendibleID.unmarshal(buff);
		eventID.unmarshal(buff);
		fireMissionIndex = buff.getInt();
		locationInWorldCoordinates.unmarshal(buff);
		descriptor.unmarshal(buff);
		velocity.unmarshal(buff);
		range = buff.getFloat();
	} // end of unmarshal method
} // end of class
