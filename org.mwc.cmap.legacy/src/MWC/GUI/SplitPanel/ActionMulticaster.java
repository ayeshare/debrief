/*******************************************************************************
 * Debrief - the Open Source Maritime Analysis Application
 * http://debrief.info
 *
 * (C) 2000-2020, Deep Blue C Technology Ltd
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the Eclipse Public License v1.0
 * (http://www.eclipse.org/legal/epl-v10.html)
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *******************************************************************************/

//--------------------------------------------------------------------------------------------------
// Copyright (c) 1996, 1996 Borland International, Inc. All Rights Reserved.
//--------------------------------------------------------------------------------------------------

package MWC.GUI.SplitPanel;

//import java.util.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 *
 */
public class ActionMulticaster implements ActionListener {
	// ActionListener Implementation

	private ActionListener[] listeners;

	@Override
	public void actionPerformed(final ActionEvent e) {
		if (listeners != null)
			dispatch(e);
	}

	/**
	 *
	 */
	public synchronized final void add(final ActionListener listener) {
		if (find(listener) < 0) {
			ActionListener[] newListeners;

			if (listeners == null)
				newListeners = new ActionListener[1];
			else {
				newListeners = new ActionListener[listeners.length + 1];
				System.arraycopy(listeners, 0, newListeners, 0, listeners.length);
			}

			newListeners[newListeners.length - 1] = listener;
			listeners = newListeners; // Assumed atomic.
		}
	}

	/**
	 * High speed dispatcher that does not need to be synchronized.
	 */
	public final void dispatch(final ActionEvent e) {
		// Synchronized not needed becuase all updates are made to a "copy"
		// of listeners. Assumes reference assignment is atomic.
		final ActionListener[] listenersCopy = this.listeners;

		// Once I have a local copy of the list, don't have to worry about threads
		// adding/deleting from this list since they will make a copy of the list,
		// not modify the list.
		if (listenersCopy != null) {
			final int count = listenersCopy.length;
			for (int index = 0; index < count; ++index) {
				// long time = System.currentTimeMillis();
				// Diagnostic.trace(EventMulticaster.class, "->dispatch e=" + e + " => " +
				// listenersCopy[index]);
				listenersCopy[index].actionPerformed(e);
				// Diagnostic.trace(EventMulticaster.class, " dispatch took " +
				// (System.currentTimeMillis()-time) + "ms");
			}
		}
	}

	/**
	 * Simple list management that avoids synchronized/functional interface of
	 * Vector. Key to this implementation is that all changes are made to a "copy"
	 * of the original list. This allows for non-synchronized access of listners
	 * when event dispatch is called.
	 */
	public int find(final ActionListener listener) {
		if (listeners != null) {
			for (int index = 0; index < listeners.length; ++index)
				if (listeners[index] == listener)
					return index;
		}
		return -1;
	}

	/**
	 * High speed test to see if any listeners present.
	 */
	public final boolean hasListeners() {
		return listeners != null;
	}

	/**
	 *
	 */
	public synchronized final void remove(final ActionListener listener) {
		final int index = find(listener);
		if (index > -1) {
			// Important: hasListeners() expects listeners too be null if there are no
			// listeners.
			if (listeners.length == 1)
				listeners = null;
			else {
				final ActionListener[] newListeners = new ActionListener[listeners.length - 1];
				System.arraycopy(listeners, 0, newListeners, 0, index);

				if (index < newListeners.length)
					System.arraycopy(listeners, index + 1, newListeners, index, newListeners.length - index);

				listeners = newListeners; // Assumed atomic.
			}
		}
	}
}
